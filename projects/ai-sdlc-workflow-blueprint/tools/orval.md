# Orval - OpenAPI TypeScript Generator for React Applications

## Overview

Orval is a modern TypeScript generator for OpenAPI schemas that automatically creates type-safe API clients and React Query hooks. It provides zero-configuration integration with React 19, TanStack Query, and modern development workflows, making it the optimal choice for maritime insurance applications requiring robust API integration.

## Key Benefits

### 1. **Built-in React Query Integration**
- Automatic generation of TanStack Query hooks
- Optimistic updates and caching strategies
- Perfect integration with React 19 concurrent features
- Zero manual hook configuration required

### 2. **Superior Developer Experience**
- Minimal configuration setup (5 minutes)
- Watch mode for automatic regeneration
- Full TypeScript inference and type safety
- Excellent IDE support with autocomplete

### 3. **Maritime-Optimized Features**
- Complex nested data structure support
- File upload patterns for insurance documents
- Role-based access control integration
- Real-time synchronization patterns

### 4. **Performance Excellence**
- Minimal bundle impact (5-10KB overhead)
- Tree-shaking compatible generated code
- Efficient network request handling
- Automatic request deduplication

## Configuration Examples

### Basic Orval Configuration

```javascript
// orval.config.js
export default {
  maritimeInsurance: {
    input: 'http://localhost:8000/openapi.json',
    output: {
      target: 'src/api/maritime-api.ts',
      client: 'react-query',
      mode: 'split', // Generate separate files per endpoint
      override: {
        mutator: {
          path: './src/api/mutator.ts',
          name: 'customInstance',
        },
      },
    },
    hooks: {
      afterAllFilesWrite: ['prettier --write'],
    },
  },
};
```

### Advanced Configuration for Maritime Insurance

```javascript
// orval.config.js - Production Ready
export default {
  maritimeInsurance: {
    input: {
      target: 'http://localhost:8000/openapi.json',
      validation: false, // Skip validation for development speed
    },
    output: {
      target: 'src/api/generated',
      client: 'react-query',
      mode: 'tags-split', // Organize by OpenAPI tags
      mock: true, // Generate mock data for testing
      prettier: true,
      override: {
        mutator: {
          path: './src/api/maritime-mutator.ts',
          name: 'maritimeApiInstance',
        },
        query: {
          useQuery: true,
          useInfinite: true,
          useInfiniteQueryParam: 'page',
          options: {
            staleTime: 300000, // 5 minutes for maritime data
            retry: 10, // Aggressive retry for ship connectivity
          },
        },
        header: [
          '// Maritime Insurance API Client',
          '// Auto-generated by Orval - DO NOT EDIT',
          '',
        ],
      },
    },
  },
};
```

## Maritime Insurance Application Examples

### 1. FastAPI Backend Integration

```python
# FastAPI Backend - main.py
from fastapi import FastAPI, UploadFile, File
from pydantic import BaseModel
from typing import List, Optional
from enum import Enum

app = FastAPI(
    title="Maritime Insurance API",
    description="Comprehensive maritime insurance platform",
    version="1.0.0",
)

class CoverageType(str, Enum):
    hull = "hull"
    cargo = "cargo"
    liability = "liability"

class PolicyStatus(str, Enum):
    draft = "draft"
    active = "active"
    expired = "expired"
    cancelled = "cancelled"

class Policy(BaseModel):
    id: str
    user_id: str
    vessel_id: str
    coverage_type: CoverageType
    premium: float
    status: PolicyStatus
    created_at: datetime
    documents: Optional[List[str]] = []

@app.get("/policies", response_model=List[Policy])
async def get_policies(
    user_id: Optional[str] = None,
    status: Optional[PolicyStatus] = None,
    limit: int = 50
):
    # Implementation here
    pass

@app.post("/policies", response_model=Policy)
async def create_policy(policy: Policy):
    # Implementation here
    pass

@app.post("/policies/{policy_id}/documents")
async def upload_document(
    policy_id: str,
    file: UploadFile = File(...)
):
    # File upload implementation
    pass
```

### 2. Generated React Hooks Usage

```typescript
// Generated hooks usage in React components
import { 
  useGetPolicies, 
  useCreatePolicy, 
  useUploadDocument,
  Policy,
  CoverageType,
  PolicyStatus 
} from '../api/generated/maritime-api';

// Policy Management Component
const PolicyDashboard: React.FC = () => {
  // Auto-generated hook with maritime-optimized caching
  const { 
    data: policies, 
    isLoading, 
    error,
    refetch 
  } = useGetPolicies({
    query: {
      staleTime: 5 * 60 * 1000, // 5min cache for maritime data
      retry: 10, // Aggressive retry for ship connectivity
      refetchOnWindowFocus: true,
    }
  });

  // Mutation with optimistic updates
  const { mutate: createPolicy, isPending } = useCreatePolicy({
    mutation: {
      onSuccess: () => {
        // Automatic cache invalidation
        refetch();
      },
      onError: (error) => {
        console.error('Policy creation failed:', error);
      },
    },
  });

  const handleCreatePolicy = (policyData: Omit<Policy, 'id'>) => {
    createPolicy({
      data: {
        ...policyData,
        id: crypto.randomUUID(),
        created_at: new Date().toISOString(),
        status: PolicyStatus.draft,
      }
    });
  };

  if (isLoading) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;

  return (
    <div className="policy-dashboard">
      <h1>Maritime Insurance Policies</h1>
      <PolicyForm onSubmit={handleCreatePolicy} isLoading={isPending} />
      <PolicyList policies={policies || []} />
    </div>
  );
};
```

### 3. Custom API Instance with Maritime Features

```typescript
// src/api/maritime-mutator.ts
import axios, { AxiosRequestConfig, AxiosResponse } from 'axios';
import { useAuthStore } from '../stores/auth-store';

// Custom instance with maritime-specific configurations
export const maritimeApiInstance = axios.create({
  baseURL: process.env.REACT_APP_API_URL || 'http://localhost:8000',
  timeout: 30000, // Extended timeout for ship connectivity
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor for authentication
maritimeApiInstance.interceptors.request.use(
  (config) => {
    const token = useAuthStore.getState().token;
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    
    // Add maritime-specific headers
    config.headers['X-Maritime-Platform'] = 'insurance-portal';
    config.headers['X-Request-ID'] = crypto.randomUUID();
    
    return config;
  },
  (error) => Promise.reject(error)
);

// Response interceptor for error handling
maritimeApiInstance.interceptors.response.use(
  (response) => response,
  (error) => {
    // Maritime-specific error handling
    if (error.code === 'NETWORK_ERROR') {
      // Handle poor ship connectivity
      console.warn('Network error - likely poor ship connectivity');
    }
    
    if (error.response?.status === 401) {
      // Handle authentication errors
      useAuthStore.getState().clearAuth();
    }
    
    return Promise.reject(error);
  }
);

// Custom mutator function for Orval
export const customInstance = <T>(
  config: AxiosRequestConfig,
  options?: AxiosRequestConfig,
): Promise<T> => {
  const source = axios.CancelToken.source();
  const promise = maritimeApiInstance({
    ...config,
    ...options,
    cancelToken: source.token,
  }).then(({ data }) => data);

  // @ts-ignore
  promise.cancel = () => {
    source.cancel('Query was cancelled');
  };

  return promise;
};
```

## Performance Comparisons

### Bundle Size Analysis (Maritime Insurance App)

```bash
# Generated code analysis for typical maritime insurance API
# 50 endpoints, complex nested types, file uploads

Orval Generated Bundle:
├── Types only: ~15KB (gzipped: ~4KB)
├── React Query hooks: ~25KB (gzipped: ~7KB)
├── Runtime overhead: ~5KB (gzipped: ~2KB)
└── Total impact: ~45KB (gzipped: ~13KB)

Alternative Comparisons:
├── Manual implementation: ~80KB+ (gzipped: ~25KB+)
├── RTK Query codegen: ~65KB (gzipped: ~20KB)
├── OpenAPI Generator: ~70KB (gzipped: ~22KB)
└── Pure openapi-typescript: ~20KB (gzipped: ~6KB) - no hooks
```

### Development Speed Metrics

```bash
# Time to implement maritime insurance policy management

Manual Implementation:
├── API client setup: 2-3 days
├── Type definitions: 1-2 days
├── Hook implementations: 2-3 days
├── Error handling: 1 day
└── Total: 6-9 days

Orval Implementation:
├── Initial setup: 30 minutes
├── Configuration: 1-2 hours
├── Custom mutator: 2-3 hours
├── Integration testing: 2-3 hours
└── Total: 1 day
```

## Security Features

### 1. Type Safety

```typescript
// Generated types prevent runtime errors
interface CreatePolicyRequest {
  vessel_id: string;
  coverage_type: CoverageType; // Enum constraint
  premium: number; // Type validation
  start_date: string; // ISO date format
}

// Compile-time error prevention
const policy: CreatePolicyRequest = {
  vessel_id: "12345",
  coverage_type: "invalid_type", // ❌ TypeScript error
  premium: "not_a_number", // ❌ TypeScript error
  start_date: new Date(), // ❌ TypeScript error
};
```

### 2. API Validation

```javascript
// orval.config.js - Enhanced validation
export default {
  maritimeInsurance: {
    input: {
      target: 'http://localhost:8000/openapi.json',
      validation: true, // Enable OpenAPI validation
    },
    output: {
      override: {
        query: {
          // Add runtime validation
          signal: true, // AbortController support
          errorType: 'MaritimeApiError',
        },
      },
    },
  },
};
```

### 3. Authentication Integration

```typescript
// Secure API calls with generated hooks
const { data: sensitiveData } = useGetPolicyDetails(
  { policyId: '12345' },
  {
    query: {
      enabled: !!userToken, // Only run if authenticated
      retry: (failureCount, error) => {
        // Don't retry auth errors
        if (error.response?.status === 401) return false;
        return failureCount < 3;
      },
    },
  }
);
```

## CI/CD Integration

### 1. GitHub Actions Workflow

```yaml
name: Maritime Insurance API Integration

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  api-integration:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: 20.x
        cache: 'pnpm'
    
    - name: Install pnpm
      uses: pnpm/action-setup@v2
      with:
        version: 8
    
    - name: Install dependencies
      run: pnpm install --frozen-lockfile
    
    - name: Start FastAPI backend
      run: |
        cd backend
        python -m venv venv
        source venv/bin/activate
        pip install -r requirements.txt
        uvicorn main:app --port 8000 &
        sleep 10
    
    - name: Generate API client
      run: pnpm orval
    
    - name: Verify generated types
      run: pnpm tsc --noEmit
    
    - name: Run API integration tests
      run: pnpm test:api
    
    - name: Build application
      run: pnpm build
```

### 2. Development Workflow

```json
{
  "scripts": {
    "// API Generation": "",
    "api:generate": "orval",
    "api:watch": "orval --watch",
    "api:clean": "rm -rf src/api/generated",
    
    "// Development": "",
    "dev": "concurrently \"pnpm api:watch\" \"vite dev\"",
    "dev:api": "uvicorn backend.main:app --reload --port 8000",
    
    "// Testing": "",
    "test:api": "vitest run tests/api",
    "test:types": "tsc --noEmit",
    
    "// Pre-commit": "",
    "prepare": "husky install",
    "pre-commit": "lint-staged && pnpm api:generate && git add src/api/generated"
  }
}
```

### 3. Docker Development

```dockerfile
# Dockerfile.dev - Development with Orval
FROM node:20-alpine AS base
RUN corepack enable && corepack prepare pnpm@latest --activate

FROM base AS dependencies
WORKDIR /app
COPY package.json pnpm-lock.yaml ./
RUN pnpm install --frozen-lockfile

FROM dependencies AS development
COPY . .
COPY --from=dependencies /app/node_modules ./node_modules

# Generate API client on startup
RUN pnpm api:generate

# Watch for changes and regenerate
CMD ["sh", "-c", "pnpm api:watch & pnpm dev"]
```

## Team Collaboration Features

### 1. Generated Code Management

```bash
# .gitignore - Generated code handling
# Generated API client (commit to repo for stability)
src/api/generated/
!src/api/generated/.gitkeep

# Alternative approach - include generated code
# src/api/generated/**
# !src/api/generated/.gitignore
```

### 2. Team Development Scripts

```json
{
  "scripts": {
    "// Team Onboarding": "",
    "setup": "pnpm install && pnpm api:generate",
    "setup:clean": "pnpm api:clean && pnpm setup",
    
    "// Shared Development": "",
    "dev:team": "concurrently \"pnpm api:watch\" \"pnpm dev\" \"pnpm dev:api\"",
    "sync:api": "pnpm api:generate && git add src/api/generated",
    
    "// Quality Assurance": "",
    "validate:api": "pnpm api:generate --dry-run",
    "check:types": "tsc --noEmit --skipLibCheck",
    "lint:generated": "eslint src/api/generated --fix"
  }
}
```

### 3. Code Review Process

```typescript
// Custom eslint rules for generated code
// .eslintrc.js
module.exports = {
  overrides: [
    {
      files: ['src/api/generated/**/*.ts'],
      rules: {
        // Disable rules for generated code
        '@typescript-eslint/no-unused-vars': 'off',
        'prefer-const': 'off',
        // But keep important ones
        '@typescript-eslint/no-explicit-any': 'error',
      },
    },
  ],
};
```

## Best Practices

### 1. Configuration Management

```javascript
// orval.config.js - Production best practices
import { defineConfig } from 'orval';

export default defineConfig({
  maritimeInsurance: {
    input: {
      target: process.env.OPENAPI_URL || 'http://localhost:8000/openapi.json',
      validation: process.env.NODE_ENV === 'production',
    },
    output: {
      target: 'src/api/generated',
      client: 'react-query',
      prettier: true,
      clean: true, // Clean output directory
      override: {
        mutator: {
          path: './src/api/maritime-mutator.ts',
          name: 'customInstance',
        },
        query: {
          options: {
            staleTime: 300000, // 5 minutes
            retry: (failureCount, error) => {
              // Smart retry logic for maritime connectivity
              if (error.response?.status >= 400 && error.response?.status < 500) {
                return false; // Don't retry client errors
              }
              return failureCount < 10; // Aggressive retry for network issues
            },
          },
        },
      },
    },
    hooks: {
      afterAllFilesWrite: [
        'prettier --write src/api/generated',
        'eslint src/api/generated --fix',
      ],
    },
  },
});
```

### 2. Type Extensions

```typescript
// src/api/maritime-extensions.ts
// Extend generated types with maritime-specific functionality

import { Policy, PolicyStatus } from './generated/maritime-api';

// Add computed properties
export interface EnhancedPolicy extends Policy {
  isActive: boolean;
  daysUntilExpiry: number;
  riskLevel: 'low' | 'medium' | 'high';
}

// Policy utilities
export const enhancePolicy = (policy: Policy): EnhancedPolicy => ({
  ...policy,
  isActive: policy.status === PolicyStatus.active,
  daysUntilExpiry: calculateDaysUntilExpiry(policy.end_date),
  riskLevel: calculateRiskLevel(policy),
});

// Maritime-specific validation
export const validateVesselId = (vesselId: string): boolean => {
  return /^[A-Z]{3}[0-9]{4,7}$/.test(vesselId); // IMO number format
};
```

### 3. Error Handling Patterns

```typescript
// src/api/maritime-error-handling.ts
import { AxiosError } from 'axios';

export class MaritimeApiError extends Error {
  constructor(
    public originalError: AxiosError,
    public context: string
  ) {
    super(`Maritime API Error in ${context}: ${originalError.message}`);
  }
}

// Custom error handling hook
export const useMaritimeErrorHandler = () => {
  return (error: AxiosError, context: string) => {
    // Log to maritime-specific monitoring
    console.error('Maritime API Error:', {
      context,
      status: error.response?.status,
      message: error.message,
      timestamp: new Date().toISOString(),
    });

    // Handle specific maritime errors
    if (error.response?.status === 409) {
      // Policy conflict - likely already exists
      throw new MaritimeApiError(error, `Policy conflict in ${context}`);
    }

    if (error.code === 'ECONNABORTED') {
      // Timeout - common with ship connectivity
      throw new MaritimeApiError(error, `Network timeout in ${context}`);
    }

    throw new MaritimeApiError(error, context);
  };
};
```

## Pricing and Licensing

- **License**: MIT (Open Source)
- **Cost**: Free
- **Enterprise Support**: Community-driven
- **Maintenance**: Active development with regular updates

## Migration Guide

### From Manual API Clients

```typescript
// Before: Manual implementation
const fetchPolicies = async (): Promise<Policy[]> => {
  const response = await fetch('/api/policies');
  if (!response.ok) throw new Error('Failed to fetch');
  return response.json();
};

const usePolicies = () => {
  const [data, setData] = useState<Policy[]>([]);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    fetchPolicies().then(setData).finally(() => setLoading(false));
  }, []);
  
  return { data, loading };
};

// After: Orval-generated hooks
const { data, isLoading } = useGetPolicies();
```

### From RTK Query

```typescript
// RTK Query migration to Orval
// Before: RTK Query
const policiesApi = createApi({
  reducerPath: 'policies',
  baseQuery: fetchBaseQuery({ baseUrl: '/api/' }),
  endpoints: (builder) => ({
    getPolicies: builder.query<Policy[], void>({
      query: () => 'policies',
    }),
  }),
});

// After: Orval (zero configuration)
const { data: policies } = useGetPolicies();
```

## Troubleshooting

### Common Issues

```bash
# OpenAPI schema validation errors
pnpm orval --debug

# Clear cache and regenerate
pnpm api:clean && pnpm api:generate

# Fix TypeScript compilation errors
pnpm tsc --noEmit --skipLibCheck

# Watch mode not working
# Check file permissions and paths in orval.config.js
```

### Performance Optimization

```javascript
// orval.config.js - Performance optimizations
export default {
  maritimeInsurance: {
    output: {
      // Split by tags for better tree-shaking
      mode: 'tags-split',
      // Enable clean builds
      clean: true,
      override: {
        // Custom file naming for better caching
        fileNameTemplate: '{{tag}}.{{extension}}',
        // Optimize imports
        useNamedExports: true,
      },
    },
  },
};
```

## Integration with Development Tools

### VS Code Settings

```json
{
  "typescript.preferences.importModuleSpecifier": "relative",
  "editor.codeActionsOnSave": {
    "source.organizeImports": true
  },
  "files.associations": {
    "orval.config.*": "javascript"
  }
}
```

### Pre-commit Hooks

```json
{
  "lint-staged": {
    "src/api/generated/**/*.ts": [
      "prettier --write",
      "eslint --fix"
    ],
    "orval.config.js": [
      "eslint --fix"
    ]
  }
}
```

## Conclusion

Orval provides exceptional value for maritime insurance applications through its seamless React 19 integration, automatic TanStack Query hook generation, and minimal configuration overhead. Its TypeScript-first approach ensures type safety across the entire API layer while maintaining excellent performance characteristics and developer experience.

The framework's active maintenance, comprehensive documentation, and strong community support make it the optimal choice for modern React applications requiring robust OpenAPI integration with maritime-specific requirements like offline support, file uploads, and complex data structures.